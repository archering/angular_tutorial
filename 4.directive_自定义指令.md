# angular tutorial  / angular 教程

## 4，自定义指令

指令是angular内部用来支配或者说操作dom的标记。
之前我们用到的指令，*ngIf, *ngFor, ng-content，ngStyle, ngClass等都是angular自带的内部指令，已经封装到了@angular/core里面

####  自定义指令， custome directive

我们自定义一个指令 myHover ,这个指令的作用就是当你鼠标hover到他上面时变换背景色和前景色。

你可以手工创建，也可以用下面的指令创建

    ng  generate directive myHover

或者

    ng  g d myHover


代码如下： 注意，在angular框架下，任何一个组件，指令，filter，service 都是一个class，当他们想要表现不同的特征时，需要用不同的装饰器修饰

    import { Directive } from '@angular/core';

    @Directive({
        selector: '[myHover]' //这里也可以是 myHover 表示标签形式，这里是属性形式
    })
    export class MyHoverDirective {

        constructor() { }

    }

当前，还需要挂载到合适的module上才能使用

        @NgModule({
            declarations: [
                AppComponent,
                PageComponent,
                MyHoverDirective //进行声明
            ],
            imports: [
                BrowserModule,
                FormsModule
            ],
            providers: [],
            bootstrap: [AppComponent]
        })


如何操作dom

（1）方式一，使用element和他的nativeElement（有点类似于angularjs里面的link函数）

    import { Directive, ElementRef } from '@angular/core';

    @Directive({
        selector: '[myHover]'
    })
    export class MyHoverDirective {

        constructor(private element:ElementRef) {

        }
        //这个时候就要用到声明周期函数了
        ngOnInit(){
            this.element.nativeElement.style.color = "red";
        }

    }

(2) 方式二，使用renderer2 进行操作

    export class MyHoverDirective {

        constructor(private element:ElementRef,private render:Renderer2) {

        }

        ngOnInit(){
            this.element.nativeElement.style.color = "red";
            //这里使用的是renderer2
            this.render.setStyle(this.element.nativeElement,"backgroundColor","blue");
        }

        }
    }


> 凡是Host开头的装饰器， Host只的就是当前这个指令应用·或者说作用到的dom

(3) 使用@HostListener() 来监听当前这个dom的事件

举例： 我们监听当鼠标进入这个dom时，mouseenter背景色变成绿色，mouseout时背景色变成黑色

    @Directive({
        selector: '[myHover]'
    })
    export class MyHoverDirective {

        constructor(private element:ElementRef,private render:Renderer2) {
        }
        ngOnInit(){
            this.element.nativeElement.style.color = "red";
            this.render.setStyle(this.element.nativeElement,"backgroundColor","blue");
        }
        //监听mouseenter事件
        @HostListener("mouseenter") mouseenter(ent:MouseEvent){
            this.render.setStyle(this.element.nativeElement,"backgroundColor","green");
        }
        //监听mouseout事件
        @HostListener("mouseout") mouseout(ent:MouseEvent){
            this.render.setStyle(this.element.nativeElement,"backgroundColor","yellow");
        }
    }

 (4) 使用@HostBinding() 属性装饰器操作这个dom的属性，简化操作

        export class MyHoverDirective {

            //声明一个属性装饰器，附带一个默认值（可以不设置）
            @HostBinding('style.fontSize') size:String = "12px";

            constructor(private element:ElementRef,private render:Renderer2) {
            }
            ngOnInit(){
                this.element.nativeElement.style.color = "red";
                this.render.setStyle(this.element.nativeElement,"backgroundColor","blue");
                //直接通过属性选择装饰器设置属性值
                this.size = "30px";
            }

            @HostListener("mouseenter") mouseenter(ent:MouseEvent){
                this.render.setStyle(this.element.nativeElement,"backgroundColor","green");
            }
            @HostListener("mouseout") mouseout(ent:MouseEvent){
                this.render.setStyle(this.element.nativeElement,"backgroundColor","yellow");
            }

        }


(5) 结构化指令的本质和自定义结构化指令

在angular中结构化指令都是以 *开头的指令， 但是angular中并没有 *开头定义的指令。

*abc等类似的指令在实际的运行中会被angular框架隐式的转换成普通的属性[]指令、tag指令或者

    <button (click)="toggle()">点击显示下面内容，改变showme的值</button>
    <div *ngIf="showme">
        <p>正常的 ngIf指令作用的标签</p>
    </div>

----

实际上上面的*ngIf 被装换成了下面正常的[ngIf], ng-template 这个标签正常情况下是不会被渲染的

    <ng-template [ngIf]="showme">
        <div>
        <p>这里显示的是实际的 ngIf的样子</p>
        </div>
    </ng-template>

以上两段dom可以同时使用，效果一样